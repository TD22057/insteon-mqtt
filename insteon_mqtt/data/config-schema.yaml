## DO NOT EDIT THIS FILE
##
## This schema is used to validate the config settings before loading.
## The validation enforces certain rules for each setting including:
##    - Type - Is the setting specified in the expected form
##    - Presence - Is the setting defined when it should be
##    - Content - Is the content of the setting something allowed
## Plus other unique tests are performed as well.  This helps catch errors
## that may otherwise be hard to diagnose once the program is loaded.
## The schema is interpreted by Cerberus, which you can read more about
## here: https://docs.python-cerberus.org/en/stable/index.html
##
## Yaml anchors & and aliases * are used extensively here to avoid duplicate
## coding.  Please read about them here
## https://ktomk.github.io/writing/yaml-anchor-alias-and-merge-key.html
##
## Merge keys were not used because they are already deprecated and not
## not supported in yaml 1.2.


logging:
  type: dict
  allow_unknown: True
  schema:
    level:
      type: integer
      min: 5
      max: 40
    file:
      type: string
    screen:
      type: boolean
insteon:
  allow_unknown: True
  type: dict
  schema:
    port:
      type: string
    baudrate:
      type: integer
      min: 110
      max: 256000
    use_hub:
      type: boolean
      oneof:
        # If hub_enabled require hub fields, else require PLM port
        - allowed: [True]
          dependencies: ['hub_ip', 'hub_user', 'hub_password']
          meta:
            allowed_error: use_hub must be True
        - allowed: [False]
          dependencies: ['port']
          meta:
            allowed_error: use_hub must be False
      meta:
        oneof_error: >-
          Required PLM or Hub fields are not properly configured.  One of the
          two following definitions must be satisfied.
    hub_ip:
      type: string
    hub_port:
      type: integer
      min: 0
      max: 65535
    hub_user:
      type: string
    hub_password:
      type: string
    address: &insteon_addr
      # A true integer could be validated with min/max here.  But we already
      # have code to handle a str representation of an integer, so might as
      # well pass integers to the check_with anyways
      type: ['string', 'integer']
      check_with: valid_insteon_addr
      meta:
        type_error: |-
          Insteon Addresses can be represented as:
           aa.bb.cc, aabbcc, or aa:bb:cc
    storage:
      type: string
    startup_refresh:
      type: boolean
    scenes:  # Scene file is validated in a separate schema
      type: string
    devices:
      allow_unknown: False
      type: dict
      keysrules:
        type: string
        allowed: ['switch', 'dimmer', 'battery_sensor', 'hidden_door',
                  'motion', 'mini_remote1', 'mini_remote4',
                  'mini_remote8', 'smoke_bridge', 'fan_linc',
                  'keypad_linc', 'keypad_linc_sw', 'leak', 'io_linc',
                  'outlet', 'thermostat', 'ezio4o']
      valuesrules:
        type: list
        nullable: True
        schema:
          oneof:
            # Opt1 Only address specified
            - &insteon_addr_short_error
              type: ['string', 'integer']
              check_with: valid_insteon_addr
              meta:
                type_error: Not a valid Insteon Address format.
            # Opt2 Address: Name
            - type: dict
              meta:
                type_error: "Entry was not in 'address: name' format"
              keysrules: *insteon_addr_short_error
              valuesrules:
                type: string
                meta:
                  type_error: >-
                    Device entry value should be a name in string form.
            # Opt3 Entry with additional settings, which can only be partially validated
            # here, so runtime code will do the remaining validation.
            # Setting minlength ensures this broad test only applies when
            # additional keys are present
            - type: dict
              keysrules:
                type: ['string', 'integer']
                meta:
                  type_error: Key field must be a string or integer
              minlength: 2
              meta:
                minlength_error: Entry did not have any extra config settings
                type_error: "Entry was not in 'address: name' format"
              allow_unknown: True
              schema:
                discoverable:
                  type: boolean
                discovery_class:
                  type: string
                discovery_override_class:
                  type: ['string', 'list']
                  schema:
                    type: string
                discovery_overrides: &discovery_overrides
                  nullable: True
                  type: dict
                  keysrules:
                    type: string
                    meta:
                      type_error: Discovery override entity key must be a string
                  schema:
                    device: &discovery_device
                      nullable: True
                      type: dict
                      schema:
                        cu:
                          type: string
                        cns:
                          type: string
                        ids:
                          type: string
                        name:
                          type: string
                        mf:
                          type: string
                        mdl:
                          type: string
                        sa:
                          type: string
                        sw:
                          type: string
                        via_device:
                          type: string
                  allow_unknown:
                    type: dict
                    schema:
                      discoverable:
                        type: boolean
                        oneof:
                          # If entity not discoverable, cannot supply 'component' or 'config' overrides
                          - allowed: [False]
                            excludes: ['component', 'config']
                          - allowed: [True]
                      component:
                        type: string
                        allowed: ['alarm_control_panel', 'binary_sensor', 'camera',
                                  'cover', 'device_tracker', 'device_trigger', 'fan',
                                  'climate', 'light', 'lock', 'scene', 'sensor',
                                  'switch', 'tag', 'vacuum']
                      config:
                        nullable: True
                        type: dict
                        keysrules:
                          type: string
                          meta:
                            type_error: Payload override attribute must be a string
          meta:
            oneof_error: |
              This entry does not match a valid device entry format.
              Insteon Addresses can be represented as:
               aa.bb.cc, aabbcc, or aa:bb:cc
              Device entries can use one of the following forms:
               - aa.bb.cc
               - aa.bb.cc: Device Name
               - aa.bb.cc: Device Name
                 extra_setting: Extra configuration setting

mqtt:
  type: dict
  keysrules:
    type: string
    meta:
      type_error: MQTT entry must be a string
  allow_unknown:
    allow_unknown: False
    ## The only unknown keys are user defined discovery_class settings
    type: dict
    schema:
      # A definition of a class with its own entities
      discovery_entities: &discovery_entities
        excludes: ['discovery_overrides']
        oneof:
          - type: dict
            keysrules:
              type: string
              forbidden: ['device']
              meta:
                type_error: Discovery entity key must be a string
            valuesrules:
              type: dict
              schema: &discovery_entity
                component:
                  type: string
                  allowed: ['alarm_control_panel', 'binary_sensor', 'camera',
                            'cover', 'device_tracker', 'device_trigger', 'fan',
                            'climate', 'light', 'lock', 'scene', 'sensor',
                            'switch', 'tag', 'vacuum']
                config:
                  oneof:
                    - type: string
                    - type: dict
                      keysrules:
                        type: string
                        meta:
                          type_error: Payload attribute must be a string
                  required: True
          - type: list
            schema:
              type: dict
              schema: *discovery_entity
      # A definition of a class containing overrides for another class
      discovery_overrides: *discovery_overrides
  schema:
    broker:
      type: string
      required: True
    port:
      type: integer
      required: True
      min: 0
      max: 65535
    username:
      type: string
    password:
      type: string
    id:
      type: string
    encryption:
      nullable: True
      type: dict
      schema:
        ca_cert:
          type: string
        certfile:
          type: string
        keyfile:
          type: string
        tls_version:
          type: string
          allowed: ['tls', 'tlsv1', 'tlsv11', 'tlsv12', 'sslv2', 'sslv23',
                    'sslv3']
        ciphers:
          type: string
        cert_reqs:
          type: string
          allowed: ['none', 'optional', 'required']
    keep_alive:
      type: integer
      min: 0
    qos:
      type: integer
      min: 0
      max: 2
    retain:
      type: ['integer', 'boolean']
      allowed: [0, 1, True, False]
    cmd_topic: &mqtt_topic
      type: string
      regex: '^[^/+][^+]*[^/+#]$'
      meta:
        regex_error: >-
          MQTT Topics cannot start or end with / or # and cannot use +
    availability_topic: *mqtt_topic
    enable_discovery:
      type: boolean
    discovery_topic_base: *mqtt_topic
    discovery_ha_status: *mqtt_topic
    device_info_template: *discovery_device
    modem:
      type: dict
      allow_unknown: True
      schema:
        scene_topic: *mqtt_topic
        scene_payload:
          type: string
        discovery_entities: *discovery_entities
    switch:
      type: dict
      allow_unknown: True
      schema:
        state_topic: *mqtt_topic
        state_payload:
          type: string
        on_off_topic: *mqtt_topic
        on_off_payload:
          type: string
        scene_topic: *mqtt_topic
        scene_payload:
          type: string
        discovery_entities: *discovery_entities
    dimmer:
      type: dict
      allow_unknown: True
      schema:
        state_topic: *mqtt_topic
        state_payload:
          type: string
        manual_state_topic: *mqtt_topic
        manual_state_payload:
          type: string
        on_off_topic: *mqtt_topic
        on_off_payload:
          type: string
        level_topic: *mqtt_topic
        level_payload:
          type: string
        scene_topic: *mqtt_topic
        scene_payload:
          type: string
        discovery_entities: *discovery_entities
    battery_sensor:
      type: dict
      allow_unknown: True
      schema:
        state_topic: *mqtt_topic
        state_payload:
          type: string
        low_battery_topic: *mqtt_topic
        low_battery_payload:
          type: string
        heartbeat_topic: *mqtt_topic
        heartbeat_payload:
          type: string
        discovery_entities: *discovery_entities
    motion:
      type: dict
      allow_unknown: True
      schema:
        dawn_dusk_topic: *mqtt_topic
        dawn_dusk_payload:
          type: string
        discovery_entities: *discovery_entities
    hidden_door:
      type: dict
      allow_unknown: True
      schema:
        battery_voltage_topic: *mqtt_topic
        battery_voltage_payload:
          type: string
        discovery_entities: *discovery_entities
    leak:
      type: dict
      allow_unknown: True
      schema:
        wet_dry_topic: *mqtt_topic
        wet_dry_payload:
          type: string
        discovery_entities: *discovery_entities
    remote:
      type: dict
      allow_unknown: True
      schema:
        state_topic: *mqtt_topic
        state_payload:
          type: string
        discovery_entities: *discovery_entities
    smoke_bridge:
      type: dict
      allow_unknown: True
      schema:
        battery_topic: *mqtt_topic
        battery_payload:
          type: string
        co_topic: *mqtt_topic
        co_payload:
          type: string
        error_topic: *mqtt_topic
        error_payload:
          type: string
        smoke_topic: *mqtt_topic
        smoke_payload:
          type: string
        discovery_entities: *discovery_entities
    thermostat:
      type: dict
      allow_unknown: True
      schema:
        ambient_temp_topic: *mqtt_topic
        ambient_temp_payload:
          type: string
        cool_sp_command_topic: *mqtt_topic
        cool_sp_payload:
          type: string
        cool_sp_state_topic: *mqtt_topic
        cool_sp_state_payload:
          type: string
        energy_state_topic: *mqtt_topic
        energy_state_payload:
          type: string
        fan_command_topic: *mqtt_topic
        fan_command_payload:
          type: string
        fan_state_topic: *mqtt_topic
        fan_state_payload:
          type: string
        heat_sp_command_topic: *mqtt_topic
        heat_sp_payload:
          type: string
        heat_sp_state_topic: *mqtt_topic
        heat_sp_state_payload:
          type: string
        hold_state_topic: *mqtt_topic
        hold_state_payload:
          type: string
        humid_state_topic: *mqtt_topic
        humid_state_payload:
          type: string
        mode_command_topic: *mqtt_topic
        mode_command_payload:
          type: string
        mode_state_topic: *mqtt_topic
        mode_state_payload:
          type: string
        status_state_topic: *mqtt_topic
        status_state_payload:
          type: string
        discovery_entities: *discovery_entities
    fan_linc:
      type: dict
      allow_unknown: True
      schema:
        fan_state_topic: *mqtt_topic
        fan_state_payload:
          type: string
        fan_on_off_topic: *mqtt_topic
        fan_on_off_payload:
          type: string
        fan_speed_topic: *mqtt_topic
        fan_speed_payload:
          type: string
        fan_speed_set_topic: *mqtt_topic
        fan_speed_set_payload:
          type: string
        discovery_entities: *discovery_entities
    keypad_linc:
      type: dict
      allow_unknown: True
      schema:
        btn_state_topic: *mqtt_topic
        btn_state_payload:
          type: string
        dimmer_state_topic: *mqtt_topic
        dimmer_state_payload:
          type: string
        manual_state_topic: *mqtt_topic
        manual_state_payload:
          type: string
        btn_on_off_topic: *mqtt_topic
        btn_on_off_payload:
          type: string
        dimmer_level_topic: *mqtt_topic
        dimmer_level_payload:
          type: string
        btn_scene_topic: *mqtt_topic
        btn_scene_payload:
          type: string
        discovery_entities: *discovery_entities
    io_linc:
      type: dict
      allow_unknown: True
      schema:
        state_topic: *mqtt_topic
        state_payload:
          type: string
        relay_state_topic: *mqtt_topic
        relay_state_payload:
          type: string
        sensor_state_topic: *mqtt_topic
        sensor_state_payload:
          type: string
        on_off_topic: *mqtt_topic
        on_off_payload:
          type: string
        discovery_entities: *discovery_entities
    outlet:
      type: dict
      allow_unknown: True
      schema:
        state_topic: *mqtt_topic
        state_payload:
          type: string
        on_off_topic: *mqtt_topic
        on_off_payload:
          type: string
        discovery_entities: *discovery_entities
    ezio4o:
      type: dict
      allow_unknown: True
      schema:
        state_topic: *mqtt_topic
        state_payload:
          type: string
        on_off_topic: *mqtt_topic
        on_off_payload:
          type: string
        discovery_entities: *discovery_entities
